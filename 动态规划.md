# 动态规划



## 相关题目

* [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) ***



## 题解

### LeetCode 300

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
>
> 示例 1：
>
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> 示例 2：
>
> 输入：nums = [0,1,0,3,2,3]
> 输出：4
> 示例 3：
>
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1
>
>
> 提示：
>
> 1 <= nums.length <= 2500
> -104 <= nums[i] <= 104
>
> **进阶：你能将算法的时间复杂度降低到 O(n log(n)) 吗?**





* 以 $nums[i]$ 结尾的最长递增子序列的长度 (此处不多赘述...



***

* **DP + 贪心 + 二分**

贪心点在于：对于某一长度的最长递增子序列，如果它的**结尾元素能够尽可能的小**，那么对于后来的元素，它越有可能加入结尾使长度增加

例如：**$nums[i]$ = [1, 5, 2, 3]**

长度为 $2$ 的子序列有 **[1, 5]** **[1, 2]** ，当加入元素 $3$ 时，后者由于其结尾较小而能够使长度增加

因此我们需要一个数组保存**每个长度下，结尾元素的最小值**

这里定义 $dp[i]$：长度为 $i + 1$ 的结尾元素最小值 (~~其实综合来说，这跟dp好像没多大关系，当然可以命名为其他东西，a / nums / ...whatever you like~~)

**其次**， **$dp[i]$ 单调递增**，因为长度为 $i+1$ 的递增子序列一定是由长度为 $i$ 的递增子序列添加元素而来，如果长度为 $i$ 的递增子序列的 「最小尾数」 为 $X$，则添加的元素一定 $>X$。

既然单调递增，那么我们就能够以 $O(log_2n)$ 的时间复杂度找到新元素 $nums[i]$ 对 $dp$ 数组中某一个修改的**位置** ，替换后能够使某一个长度的结尾元素尽可能小

**那么问题来了，这个位置是什么 “位置”？** 这个非常关键！

* 大于等于...的第一个元素？
* 小于等于...的最后一个元素？



**猜测过程如下：**

我们如果找到 **第一个 比 $nums[i]$ 大的元素 $dp[j]$** ，~~那么就可以将其替换为 $nums[i]$~~。为什么？

> 由上述，有：$dp[j - 1] \leq nums[i] < dp[j]$
>
> 因为如果 $dp[j - 1] > nums[i]$ ，则 $dp[j]$ 就不是第一个大于 $nums[i]$ 的元素
>
> 转而考虑以 $dp[j]$ 结尾的递增序列，而我们无法得知该序列的倒数第二个元素与 $nums[i]$ 的大小关系
>
> 此路不通...

既然有 $dp[j - 1] \leq nums[i] < dp[j]$ 

> 那么我们是否可以将 $nums[i]$ 接到 $dp[j - 1]$ 的所在序列的后面？但是题目要求是递增，而 $dp[j - 1]$ 有可能等于 $nums[i]$ 而无法形成严格递增的序列

既然如此，如果找到 **第一个大于等于 $nums[i]$ 的元素 $dp[j]$ ** ，

> 有：$dp[j - 1] < nums[i] \leq dp[j]$ ，同上的反证法
>
> 我们可以将 $nums[i]$ 接在 $dp[j - 1]$ 的所在序列的后面(记为 $A$)，然后该递增序列长度 $+1$ (即为 $j + 1$，)同时该序列的结尾变成 $nums[i]$ 。
>
> 又：$nums[i] \leq dp[j]$ ，新形成的长度为 $j + 1$ 的序列 $A$ 的结尾元素有可能小于 $dp[j]$ ，则可以将 $dp[j]$ 替换为 $nums[i]$ (如果等于的话替换后也不变，无所谓~~~)
>
> 其实左侧的元素都可以替换，不过并不会造成影响

***

至此，终于找到了 $nums[i]$ 的 **位置** :heavy_check_mark:



* 如果题目改成非严格递增 / 单调不见，如何改变判断条件？

  似乎去掉等号即可

* 